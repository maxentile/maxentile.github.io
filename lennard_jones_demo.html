<html>
<head>
    <style>
        body {
            margin: 0
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>
<body>
<script src="http://threejs.org/build/three.js"></script>
<script>
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); // field of view, aspect ratio, near/far clipping plane
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    colors = [0xC0FF00, 0xE8960C, 0xFF0000, 0x570CE8, 0x0DD7FF];
    meshes = [];
    for (let i = 0; i < 9**2; i++) {

        color = colors[Math.floor(Math.random() * colors.length)]; // random
        color = colors[i % colors.length]; //sequential

        meshes.push(new THREE.Mesh(
            new THREE.IcosahedronGeometry(0.25, 3),
            new THREE.MeshPhongMaterial({shininess: 0,
                color: color})));
        scene.add(meshes[i]);
    }

    positions = [];
    for (i = 0; i < meshes.length; i++) {
        positions.push(new THREE.Vector3(0, 0, 0));
    }

    velocities = [];
    for (i = 0; i < meshes.length; i++) {
        velocities.push(new THREE.Vector3(0, 0, 0));
    }

    forces = [];
    for (i = 0; i < meshes.length; i++) {
        forces.push(new THREE.Vector3(0, 0, 0));
    }

    light = new THREE.PointLight();
    light.position.z = 50;
    light.position.x = 5;
    scene.add(light);

    scene.add(new THREE.HemisphereLight(0xC0FF00, 0xE8960C, 0.05));

    camera.position.z = 5;

    noise_scale = 0.0;
    gamma = 0.1;
    stepsize = 0.0000001;
    sigma = 0.5;
    epsilon = 10000000000.0;

    function updateVelocitiesRandomly(h) {
        // Note: Must replace (Math.random() - 0.5) with Normal random variable
        a = Math.exp(-gamma * h);
        b = Math.sqrt(1 - Math.exp(-2 * gamma * h));


        for (i = 0; i < meshes.length; i++) {
            velocities[i].x = a * (velocities[i].x) + b * ((Math.random() - 0.5) * noise_scale);
            velocities[i].y = a * (velocities[i].y) + b * ((Math.random() - 0.5) * noise_scale);
            velocities[i].z = a * (velocities[i].z) + b * ((Math.random() - 0.5) * noise_scale);
        }
    }

    function computeDisplacement(a, b) {
        // a, b are THREE.Vector3's
        return new THREE.Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
    }

    function computeDistance(a, b) {
        c = computeDisplacement(a, b);
        return Math.sqrt(c.x ** 2 + c.y ** 2 + c.z ** 2);
    }

    function lennardJonesPotential(a, b, sigma, epsilon) {
        r = computeDistance(a, b);
        return 4 * epsilon * ((sigma / r) ** 12 - (sigma / r) ** 6);
    }

    function lennardJonesForce(a, b, sigma, epsilon) {
        // gradient of lennardJonesPotential w.r.t. displacement vector c...
        c = computeDisplacement(a, b);
        r2 = computeDistance(a, b) ** 2;

        f = new THREE.Vector3(0, 0, 0);

        f.x = -4 * epsilon * ((6 * c.x * sigma ** 6) / (r2) ** (7 / 2) - (12 * c.x * sigma ** 12) / (r2) ** (13 / 2));
        f.y = -4 * epsilon * ((6 * c.y * sigma ** 6) / (r2) ** (7 / 2) - (12 * c.y * sigma ** 12) / (r2) ** (13 / 2));
        f.z = -4 * epsilon * ((6 * c.z * sigma ** 6) / (r2) ** (7 / 2) - (12 * c.z * sigma ** 12) / (r2) ** (13 / 2));
        return f;
    }

    function evaluateForces() {

        for (i = 0; i < meshes.length; i++) {
            forces[i].x = 0;
            forces[i].y = 0;
            forces[i].z = 0;
        }

        for (i = 0; i < meshes.length; i++) {

            for (let j = 0; j < i; j++) {
                f = lennardJonesForce(positions[i], positions[j], sigma, epsilon);


                forces[i].x += f.x;
                forces[j].x -= f.x;

                forces[i].y += f.y;
                forces[j].y -= f.y;

                forces[i].z += f.z;
                forces[j].z -= f.z;
            }
        }

        return forces
    }

    function updateVelocitiesFromForces(h) {
        for (i = 0; i < meshes.length; i++) {
            velocities[i].x += h * forces[i].x;
            velocities[i].y += h * forces[i].y;
            velocities[i].z += h * forces[i].z;
        }
    }

    function updatePositions(h) {
        for (i = 0; i < meshes.length; i++) {
            positions[i].x += h * velocities[i].x;
            positions[i].y += h * velocities[i].y;
            positions[i].z += h * velocities[i].z;
        }
    }

    function setMeshesToPositions() {
        for (i = 0; i < meshes.length; i++) {
            meshes[i].position.x = positions[i].x;
            meshes[i].position.y = positions[i].y;
            meshes[i].position.z = positions[i].z;
        }
    }

    // initialize on a 2D grid
    pos_index = 0;
    center = (sigma * Math.sqrt(meshes.length)/2);
    for (i = 0; i < Math.sqrt(meshes.length); i ++ ) {
        for (j = 0; j < Math.sqrt(meshes.length); j ++) {
            positions[pos_index].x = i * sigma * 1.03 - center;
            positions[pos_index].y = j * sigma * 1.03 - center;
            pos_index += 1;
        }
    }

    setMeshesToPositions();

    function animate() {
        requestAnimationFrame(animate); // e.g. pause when user navigates to another tab
        renderer.render(scene, camera);

        updateVelocitiesFromForces(stepsize / 2);
        updatePositions(stepsize / 2);
        updateVelocitiesRandomly(stepsize);
        updatePositions(stepsize / 2);
        evaluateForces();
        updateVelocitiesFromForces(stepsize / 2);

        setMeshesToPositions();
    }

    animate();
</script>
</body>
</html>